% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Knapsack},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage[normalem]{ulem}
% Avoid problems with \sout in headers with hyperref
\pdfstringdefDisableCommands{\renewcommand{\sout}{}}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi

\title{Knapsack}
\author{}
\date{}

\begin{document}
\maketitle

\hypertarget{problem-statement}{%
\subsection{Problem Statement}\label{problem-statement}}

Say you have a knapsack of size {\(W\)} ({\(W \in I,W > 0\)}). You have
{\(n\)} indivisible items to put in that knapsack. Each item has a
weight of {\(w_{i}\)} , and value of {\(v_{i}\)} . Your goal is to
maximise the value inside the knapsack, without overfilling it.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{greedy-approach}{%
\subsection{Greedy Approach}\label{greedy-approach}}

Start by picking the ball with highest value of {\(v_{i}/w_{i}\)} .
Repeat this until the knapsack is filled.

While this approach seems intuitive, it may fail.

Consider this example

\begin{longtable}[]{@{}lll@{}}
\toprule
{\(w_{i}\)} & {\(v_{i}\)} & {\(v_{i}/w_{i}\)} \\
\midrule
\endhead
1 & 2 & 2 \\
100 & 199 & 1.99 \\
\bottomrule
\end{longtable}

{\(W = 100\)}

in this case, the greedy approach starts by picking the first item. Then
it picks one of the remaining items. This gives us a final value of 2 in
the knapsack. Meanwhile, by picking the last item, one can get a value
of 199. This can be extended to get a ratio between the optimal and
greedy value as high as possible.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{recursive-approach}{%
\subsection{Recursive Approach}\label{recursive-approach}}

{\(I_{i}\)} := the {\(i^{\prime}th\)} item\\
{\(w_{i}\)} := weight of the {\(i^{\prime}th\)} item\\
{\(v_{i}\)} := value of the {\(i^{\prime}th\)} item\\
{\(W\)} := maximum weight in knapsack\\
{\(w\)} := weight of knapsack in subproblem\\
{\(vmax(i,w)\)} := optimal solution for given value of {\(i\)} and
{\(w\)}

Consider the final state in which we have every optimal item in the
knapsack. Now let us follow the steps of this approach in reverse.

Say the last item was in the knapsack. So we remove this item. Now the
knapsack is optimal for a weight up till {\(W - w_{n}\)} , and can only
contain items between {\(1\)} and {\(n - 1\)}.

Otherwise, the last item cannot be in the knapsack. So, the knapsack
must contain items between {\(1\)} and {\(n - 1\)}, and must be optimal
up to a weight of {\(W\)}.

Now we end up in the same state as before. We can repeat this till we
get to any {\(i^{\prime}th\)} item. So, the recurrence relation for the
{\(i^{\prime}th\)} item is given as

\[vmax(i,w) = max\left\{ \begin{matrix}
{vmax(i - 1,w - w_{i}) + v_{i}} & {\quad I_{i}\; chosen} \\
{vmax(i - 1,w)} & {\quad I_{i}\; not\ chosen} \\
\end{matrix} \right.\]

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{recursive-algorithm}{%
\subsection{Recursive Algorithm}\label{recursive-algorithm}}

Base Cases:

\begin{itemize}
\tightlist
\item
  for {\(w = 0\)}, {\(vmax = 0\)} \{there is no space to add elements\}
\item
  for {\(i = 0\)}, {\(vmax = 0\)} \{there are no elements to add\}
\end{itemize}

Recursive Case:

\begin{itemize}
\tightlist
\item
  {\(vmax(i,w) = max(vmax(i - 1,w - w_{i}) + v_{i},vmax(i - 1,w))\)}
\end{itemize}

Starting:

\begin{itemize}
\tightlist
\item
  {\(vmax(n,W)\)}
\end{itemize}

\hypertarget{runtime}{%
\paragraph{Runtime}\label{runtime}}

This algorithm has a runtime of {\(O(2^{n})\)}, which again kinda sucks.

\hypertarget{memoisation}{%
\paragraph{Memoisation}\label{memoisation}}

With the power of memoisation, we can reduce the runtime to {\(O(nW)\)}
\{which needn't necessarily be better than {\(2^{n}\)}, but it'll mostly
be\}.

However, we will need {\(O(nW)\)} space to use memoisation. This isn't
always desirable.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{runtime-demonstration}{%
\subsection{Runtime Demonstration}\label{runtime-demonstration}}

\begin{longtable}[]{@{}lll@{}}
\toprule
I & w & v \\
\midrule
\endhead
1 & 4 & 3 \\
2 & 3 & 2 \\
3 & 2 & 4 \\
4 & 3 & 4 \\
\bottomrule
\end{longtable}

{\(W = 6\)}

\begin{longtable}[]{@{}llllllll@{}}
\toprule
i\textbackslash w & 0 & 1 & 2 & 3 & 4 & 5 & 6 \\
\midrule
\endhead
\textbf{0} & 0 & \uline{0} & 0 & 0 & 0 & 0 & 0 \\
\textbf{1} & 0 & \uline{0} & 0 & 0 & 3 & 3 & 3 \\
\textbf{2} & 0 & \uline{0} & 0 & 2 & 3 & 3 & 3 \\
\textbf{3} & 0 & 0 & 4 & \uline{4} & 4 & 6 & 7 \\
\textbf{4} & 0 & 0 & 4 & 4 & 4 & 8 & \uline{8} \\
\bottomrule
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{iterative-approach}{%
\subsection{Iterative Approach}\label{iterative-approach}}

An iterative approach to this problem just focuses on filling the table.
We can traverse row major or column major.

\begin{verbatim}
for w = 0 to W:
    vmax[0, w] = 0
for i = 1 to n:
    for i = 0 to W:
        if (wt[i] > w):
            vmax[i, w] = vmax[i-1, w]
        else:
            vmax[i, w] = max(vmax[i-1, w], vmax[i-1, w - wt[i]] + v[i])
return vmax[n, W]
Copy
\end{verbatim}

\end{document}
